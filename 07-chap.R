## ----initialize, echo = FALSE, message = FALSE, error = FALSE, warning = FALSE----
source("../chapter-setup.R"); chaptersetup("/Users/Susan/Courses/CUBook-html/CUBook/Chap8-IntroMultivariate/PCA.Rnw", "8")
knitr::opts_chunk$set(dev = 'png', dpi = 100, fig.margin = TRUE, fig.show = 'hold', fig.keep = 'none')

## ---- TheMatrix, eval = TRUE, echo = FALSE, fig.show = 'hold', fig.keep = 'high'----
knitr::include_graphics(c('images/TheMatrix.jpg'))

## ----turtlesreadin-------------------------------------------------------
turtles = read.table("../data/PaintedTurtles.txt", header = TRUE)
turtles[1:4, ]

## ----prepareathlete, echo = FALSE, eval = FALSE--------------------------
## library("ade4")
## data("olympic")
## athletes = data.frame(olympic$tab)
## names(athletes) = c("m100", "long", "weight", "highj", "m400", "m110",
##                     "disc", "pole", "javel", "m1500")
## save(athletes,file = "../data/athletes.RData")

## ----loadathletes--------------------------------------------------------
load("../data/athletes.RData")
athletes[1:3, ]

## ----checkathletes, echo = FALSE-----------------------------------------
stopifnot(nrow(athletes) == 33, ncol(athletes) == 10)
athletesSummary = lapply(athletes, function(x) c(min = min(x), max = max(x), mean = mean(x), sd = sd(x)))

## ----melanomatcell-------------------------------------------------------
load("../data/Msig3transp.RData")
round(Msig3transp,2)[1:5, 1:6]

## ----GPotus--------------------------------------------------------------
data("GlobalPatterns", package = "phyloseq")
GPOTUs = as.matrix(t(phyloseq::otu_table(GlobalPatterns)))
GPOTUs[1:4, 6:13]


## ----airway, message = FALSE, warning = FALSE----------------------------
library("SummarizedExperiment")
data("airway", package = "airway")
assay(airway)[1:3, 1:4]

## ----readinmetabolites---------------------------------------------------
metab = t(as.matrix(read.csv("../data/metabolites.csv", row.names = 1)))
metab[1:4, 1:4]


## ---- flatland, fig.margin = FALSE, eval = TRUE, echo = FALSE, fig.show = 'hold', fig.keep = 'high', fig.cap = "xkcd: What do we mean by low-dimensional? We live in 3 dimensions, or 4 if you count time, a plane has 2 dimensions, a line has one dimension. A point is said to be zero-dimensional. For the amusing novel referenced in the cartoon see  @Abbott:1884."----
knitr::include_graphics(c('images/flatland.png'))

## ----corrturt------------------------------------------------------------
cor(turtles[, -1])

## ----turtlespairs, fig.keep = 'high', fig.cap = "All pairs of bivariate scatterplots for the three biometric measurements on painted turtles.",fig.height = 3, fig.width = 3----
library("ggplot2")
library("dplyr")
library("GGally")
ggpairs(turtles[, -1], axisLabels = "none")

## ----PairsAthletes,echo=FALSE, fig.width=4.5,fig.height=4.5--------------
ggpairs(athletes)

## ----CorrPlot, eval = FALSE, echo = FALSE--------------------------------
## ggcorr(athletes, palette = "RdYlGn", name = "rho",
##        label = FALSE, label_color = "black")

## ----heatmapathletes, fig.keep = 'high', fig.cap = "Heatmap of correlations between variables in the `athletes` data. Higher values are color coded red-orange. The hierarchical clustering shows the grouping of the related disciplines.", fig.width = 4.2, fig.height = 3.5----
library("pheatmap")
pheatmap(cor(athletes), cell.width = 10, cell.height = 10)

## ----turtlesDim12, fig.keep = 'high', fig.cap = "Turtles data projected onto the plane defined by the `width` and `height` variables: each point colored according to `sex`.", fig.width = 3.5, fig.height = 3----
apply(turtles[,-1], 2, sd)
apply(turtles[,-1], 2, mean)
scaledTurtles = scale(turtles[, -1])
apply(scaledTurtles, 2, mean)
apply(scaledTurtles, 2, sd)
data.frame(scaledTurtles, sex = turtles[, 1]) %>%
  ggplot(aes(x = width, y = height, group = sex)) +
    geom_point(aes(color = sex)) + coord_fixed()

## ---- book-chunk-1, eval = TRUE, echo = FALSE, fig.keep = 'high'---------
knitr::include_graphics('images/book_icon.png', dpi = 400)

## ----projectv, fig.keep = 'high', fig.cap = "Point $A$ is projected onto the red line generated by the vector $v$. The dashed projection line is perpendicular (or **orthogonal**) to the red line. The intersection point of the projection line and the red line is called the orthogonal projection of A onto the red line generated by the vector $v$.", echo = FALSE, fig.width = 3, fig.height = 2.5----
x1=1;x2=3;y1=1;y2=2;ax=2.5;ay=3;
df=data.frame(x=c(x1,x2,ax),y=c(y1,y2,ay))
ggplot(df,aes(x=x,y=y))+ geom_point(size=2) +
       geom_abline(intercept=0.5,slope=0.5, color="red", size=1.3) + xlim(c(0,4)) + ylim(c(0,4))+
       geom_segment(x=x1,y=y1,xend=x2-0.5,yend=y2-0.25,arrow=arrow(length = unit(0.3,"cm")),color="blue") +
       geom_segment(x=ax,y=ay,xend=x2,yend=y2,arrow=arrow(length = unit(0.3,"cm")),color="orange",
       linetype = 5, size = 1.2, alpha = 0.5) + annotate("text", x = ax+0.2, y = ay+0.15, label = "A", size=6) +
       annotate("text", x = x2, y = y2-0.5, label = "proj_v(A)", size=6) +
       annotate("text", x = x1+0.75, y = y1+0.24, label = "v", size=6, color="blue") +
       annotate("text", x = x1-0.2, y = y1+ 0.2, label = "O", size=6) +
       coord_fixed() +  theme_void() + geom_point(size=2)

## ----SimpleScatter, fig.keep = 'high', fig.cap = "Scatterplot of two variables showing the projection on the horizontal x axis (defined by $y=0$) in red and the lines of projection appear as dashed.", fig.width = 3, fig.height = 3----
athletes = data.frame(scale(athletes))
ath_gg = ggplot(athletes, aes(x = weight, y = disc)) +
  geom_point(size = 2, shape = 21)
ath_gg + geom_point(aes(y = 0), colour = "red") +
  geom_segment(aes(xend = weight, yend = 0), linetype = "dashed")

## ----Reg1, fig.keep = 'high', fig.cap = "The blue line minimizes the sum of squares of the vertical residuals (in red).", fig.width = 3, fig.height = 3----
reg1 = lm(disc ~ weight, data = athletes)
a1 = reg1$coefficients[1] # intercept
b1 = reg1$coefficients[2] # slope
pline1 = ath_gg + geom_abline(intercept = a1, slope = b1,
    col = "blue", lwd = 1.5)
pline1 + geom_segment(aes(xend = weight, yend = reg1$fitted),
    colour = "red", arrow = arrow(length = unit(0.15, "cm")))

## ----Reg2, fig.keep = 'high', fig.cap = "The green line minimizes the sum of squares of the horizontal residuals (in orange).", fig.width = 3, fig.height = 3----
reg2 = lm(weight ~ disc, data = athletes)
a2 = reg2$coefficients[1] # intercept
b2 = reg2$coefficients[2] # slope
pline2 = ath_gg + geom_abline(intercept = -a2/b2, slope = 1/b2,
    col = "darkgreen", lwd = 1.5)
pline2 + geom_segment(aes(xend=reg2$fitted, yend=disc),
    colour = "orange", arrow = arrow(length = unit(0.15, "cm")))

## ----matproj1------------------------------------------------------------
var(athletes$weight) + var(reg1$fitted)

## ----matproj2, echo = FALSE----------------------------------------------
stopifnot(all.equal(c(var(athletes$weight), var(athletes$disc)), c(1,1)))

## ----PCAmin, fig.keep = 'high', fig.cap = "The purple **principal component** line minimizes the sums of squares of the orthogonal projections.", fig.width = 3, fig.height = 3----
xy = cbind(athletes$disc, athletes$weight)
svda = svd(xy)
pc = xy %*% svda$v[, 1] %*% t(svda$v[, 1])
bp = svda$v[2, 1] / svda$v[1, 1]
ap = mean(pc[, 2]) - bp * mean(pc[, 1])
ath_gg + geom_segment(xend = pc[, 1], yend = pc[, 2]) +
  geom_abline(intercept = ap, slope = bp, col = "purple", lwd = 1.5)

## ----chap8-r-PCAR1R2-1, fig.keep = 'high', fig.cap = "The blue line minimizes the sum of squares of the vertical residuals, the green line minimizes the horizontal residuals, the purple line, called the **principal component**, minimizes the orthogonal projections. Notice the ordering of the slopes of the three lines.", fig.width = 3, fig.height = 3, echo=FALSE----
pline1 + geom_segment(aes(xend = weight, yend = reg1$fitted), colour = "blue", alpha = 0.35) +
  geom_abline(intercept = -a2/b2, slope = 1/b2, col = "darkgreen", lwd = 1.5, alpha = 0.8) +
  geom_segment(aes(xend = reg2$fitted, yend = disc), colour = "orange", alpha = 0.35) +
  geom_abline(intercept = ap, slope = bp, col = "purple", lwd = 1.5, alpha = 0.8) +
  geom_segment(xend = pc[, 1], yend = pc[, 2], colour = "purple", alpha = 0.35) + coord_fixed()

## ----PCAvari-------------------------------------------------------------
apply(pc, 2, var)
sum(apply(pc, 2, var))

## ---- Vegetables, eval = TRUE, echo = FALSE, fig.show = 'hold', fig.keep = 'high'----
knitr::include_graphics(c('images/Vegetables.jpg'))

## ---- cam1, eval = TRUE, echo = FALSE, fig.show = 'hold', fig.keep = 'high', fig.cap = "A mystery silhouette."----
knitr::include_graphics(c('images/CAM3.png'))

## ---- pca, eval = TRUE, echo = FALSE, fig.show = 'hold', fig.keep = 'high', fig.cap = "Many choices have to be made during PCA processing."----
knitr::include_graphics(c('images/orgacp1.png'))

## ---- cam2, eval = TRUE, echo = FALSE, fig.show = 'hold', fig.keep = 'high', fig.cap = "Another two-dimensional projection of the same object shown in FigureÂ \\@ref(fig:cam1). Here, the perspective is more informative. Generally, choosing the perspective such that the spread (in other words, the variance) of the points is maximal generally provides most information. We want to see as much of the variation as possible, that\'s what PCA does."----
knitr::include_graphics(c('images/CAM4.png'))

## ---- kableMagic, echo=FALSE---------------------------------------------
library(kableExtra)
            t1 <- matrix(c('X',1:4,2,' ',' ',' ',' ',4,' ',' ',' ',' ',8,' ',' ',' ',' '), ncol = 4)
            t2 <- t1; t2[2:5,2] <- as.numeric(t2[2:5,1]) * 2
            t3 <- t2; t3[2:5,3] <- as.numeric(t3[2:5,2]) * 2
            t4 <- t3; t4[2:5,4] <- as.numeric(t4[2:5,3]) * 2
            
            tt1 <- knitr::kable(t1, 'html', table.attr = 'class = "console"', align = 'lrrr', col.names = c(' ', ' ',' ',' '))  %>% 
                column_spec(1, border_right = T) %>%
                row_spec(1, extra_css = 'border-bottom:1px solid black;', bold=FALSE) %>%
                row_spec(0, extra_css = 'border-bottom: 0;', bold=FALSE) %>%
                add_header_above(header = c('Step 0' = 4))
            tt2 <- knitr::kable(t2, 'html', table.attr = 'class = "console"', align = 'lrrr', col.names = c(' ', ' ',' ',' '))  %>% 
                column_spec(1, border_right = T) %>%
                row_spec(1, extra_css = 'border-bottom:1px solid black;') %>%
                row_spec(0, extra_css = 'border-bottom: 0;', bold=FALSE) %>%
                add_header_above(header = c('Step 1' = 4))
            tt3 <- knitr::kable(t3, 'html', table.attr = 'class = "console"', align = 'lrrr', col.names = c(' ', ' ',' ',' '))  %>% 
                column_spec(1, border_right = T) %>%
                row_spec(1, extra_css = 'border-bottom:1px solid black;') %>%
                row_spec(0, extra_css = 'border-bottom: 0;', bold=FALSE) %>%
                add_header_above(header = c('Step 2' = 4))
            tt4 <- knitr::kable(t4, 'html', table.attr = 'class = "console"', align = 'lrrr', col.names = c(' ', ' ',' ',' '))  %>% 
                column_spec(1, border_right = T) %>%
                row_spec(1, extra_css = 'border-bottom:1px solid black;') %>%
                row_spec(0, extra_css = 'border-bottom: 0;', bold=FALSE) %>%
                add_header_above(header = c('Step 3' = 4))
            
            knitr::kable(data.frame(as.character(tt1), as.character(tt2), as.character(tt3), as.character(tt4)), 
             col.names = NULL,
             format = 'html',
             escape = FALSE,
             table.attr = 'class = "kable_wrapper"')

## ---- mosaic0, eval = TRUE, echo = FALSE, fig.show = 'hold', fig.keep = 'high', fig.cap = "Some special matrices have numbers in them that make them easy to decompose. Each colored rectangle in this diagram has an area that corresponds to the number in it."----
knitr::include_graphics(c('images/SVD-mosaicXplot0.png'))

## ---- mosaic123, out.width = '33%', fig.margin = FALSE, eval = TRUE, echo = FALSE, fig.show = 'hold', fig.keep = 'high', fig.cap = "The numbers in the cells are equal to the product of the corresponding margins in (A), (B) and (C). We could make the cells from products in several ways. In (C) we force the margins to have norm $1$."----
knitr::include_graphics(c('images/SVD-mosaicXplot1.png','images/SVD-mosaicXplot2.png','images/SVD-mosaicXplot3.png'))

## ----checkXround, echo = -c(1, 10)---------------------------------------
.savedopt = options(digits = 3)
X = matrix(c(780,  75, 540,
             936,  90, 648,
            1300, 125, 900,
             728,  70, 504), nrow = 3)
u = c(0.8196, 0.0788, 0.5674)
v = c(0.4053, 0.4863, 0.6754, 0.3782)
s1 = 2348.2
sum(u^2)
sum(v^2)
s1 * u %*% t(v)
X - s1 * u %*% t(v)
options(.savedopt)

## ----roundsvd, results = "hide"------------------------------------------
svd(X)$u[, 1]
svd(X)$v[, 1]
sum(svd(X)$u[, 1]^2)
sum(svd(X)$v[, 1]^2)
svd(X)$d

## ----Xsubinput-----------------------------------------------------------
Xtwo = matrix(c(12.5, 35.0, 25.0, 25, 9, 14, 26, 18, 16, 21, 49, 32,
       18, 28, 52, 36, 18, 10.5, 64.5, 36), ncol = 4, byrow = TRUE)
USV = svd(Xtwo)

## ----CheckUSV------------------------------------------------------------
names(USV)
USV$d

## ----Xtwo, results = "hide"----------------------------------------------
Xtwo - USV$d[1] * USV$u[, 1] %*% t(USV$v[, 1])
Xtwo - USV$d[1] * USV$u[, 1] %*% t(USV$v[, 1]) -
       USV$d[2] * USV$u[, 2] %*% t(USV$v[, 2])

## ----checkXtwo, echo = FALSE---------------------------------------------
stopifnot(max(abs(
Xtwo - USV$d[1] * USV$u[, 1] %*% t(USV$v[, 1]) -
       USV$d[2] * USV$u[, 2] %*% t(USV$v[, 2]))) < 1e-12,
max(abs(USV$d[3:4])) < 1e-13)

## ----tUSV, results = "hide"----------------------------------------------
t(USV$u) %*% USV$u
t(USV$v) %*% USV$v

## ----turtlesvd-----------------------------------------------------------
turtles.svd = svd(scaledTurtles)
turtles.svd$d
turtles.svd$v
dim(turtles.svd$u)

## ----turtlesvdanswer-----------------------------------------------------
sum(turtles.svd$v[,1]^2)
sum(turtles.svd$d^2) / 47

## ----asserturtles, echo = FALSE------------------------------------------
stopifnot(max(abs(turtles.svd$v[,1]^2 - 1/3)) < 0.01)

## ---- eval = TRUE, echo = FALSE------------------------------------------
knitr::include_graphics('SumRankOneD')

## ----checkus, results = "hide"-------------------------------------------
turtles.svd$d[1] %*% turtles.svd$u[,1]
scaledTurtles %*% turtles.svd$v[,1]

## ----svdav---------------------------------------------------------------
svda$v[,1]

## ----pcablue, fig.keep = 'high', fig.show = "hold", fig.cap = "In the case where we only have two original variables, the PCA transformation is a simple rotation; the new coordinates are always chosen to be the horizontal and vertical axes.", fig.margin = FALSE, out.width = '50%'----
ppdf = tibble(PC1n = -svda$u[, 1] * svda$d[1],
              PC2n = svda$u[, 2] * svda$d[2])
ggplot(ppdf, aes(x = PC1n, y = PC2n)) + geom_point() + xlab("PC1 ")+
    ylab("PC2") + geom_point(aes(x=PC1n,y=0),color="red") +
    geom_segment(aes(xend = PC1n, yend = 0), color = "red") +
    geom_hline(yintercept = 0, color = "purple", lwd=1.5, alpha=0.5) +
    xlim(-3.5, 2.7) + ylim(-2,2) + coord_fixed()
segm = tibble(xmin = pmin(ppdf$PC1n, 0), xmax = pmax(ppdf$PC1n, 0), yp = seq(-1, -2, length = nrow(ppdf)), yo = ppdf$PC2n)
ggplot(ppdf, aes(x = PC1n, y = PC2n)) + geom_point() + ylab("PC2") + xlab("PC1") +
    geom_hline(yintercept=0,color="purple",lwd=1.5,alpha=0.5) +
    geom_point(aes(x=PC1n,y=0),color="red")+
    xlim(-3.5, 2.7)+ylim(-2,2)+coord_fixed() +
    geom_segment(aes(xend=PC1n,yend=0), color="red")+
    geom_segment(data=segm,aes(x=xmin,xend=xmax,y=yo,yend=yo), color="blue",alpha=0.5)

## ----answa---------------------------------------------------------------
svda$d[2]^2

## ----answb, eval=FALSE---------------------------------------------------
## sd(ppdf$PC1n)/sd(ppdf$PC2n)
## svda$d[1]/svda$d[2]


## ----PCAturtles, fig.keep = 'high', fig.cap = "The screeplot shows the eigenvalues for the standardized turtles data (`scaledTurtles`): there is one large value and two small ones. The data are (almost) one-dimensional. We will see why this dimension is called an axis of size, a frequent phenomenon in biometric data  [@Jolicoeur1960], .", fig.width = 3, fig.height = 3----
cor(scaledTurtles)
pcaturtles = princomp(scaledTurtles)
pcaturtles

library("factoextra")
fviz_eig(pcaturtles, geom = "bar", bar_width = 0.4) + ggtitle("")

## ----svdprcompprincomp, results = "hide"---------------------------------
svd(scaledTurtles)$v[, 1]
prcomp(turtles[, -1])$rotation[, 1]
princomp(scaledTurtles)$loadings[, 1]
dudi.pca(turtles[, -1], nf = 2, scannf = FALSE)$c1[, 1]

## ----quesnewvariables----------------------------------------------------
res = princomp(scaledTurtles)
PC1 = scaledTurtles %*% res$loadings[,1]
sd1 = sqrt(mean(res$scores[, 1]^2))

## ----turtlebiplot, fig.keep = 'high', fig.cap = "A biplot of the first two dimensions showing both variables and observations. The arrows show the variables. The turtles are labeled by sex. The extended horizontal direction is due to the size of the first eigenvalue, which is much larger than the second.", fig.margin = FALSE, fig.width = 9, fig.height = 2----
fviz_pca_biplot(pcaturtles, label = "var", habillage = turtles[, 1]) +
  ggtitle("")


## ----turtlesComp12,fig.width=3.5,fig.height=3.5--------------------------
pcadudit = dudi.pca(scaledTurtles, nf = 2, scannf = FALSE)
apply(pcadudit$li, 2, function(x) sum(x^2)/48)
pcadudit$eig

## ----turtlesCirclef, fig.keep = 'high', fig.cap = "Part of the \"circle of correlations\" showing the original variables. Their correlations with each other and with the new principal components are given by the angles between the vectors and between the axes and the vectors.", fig.width = 3.2, fig.height = 3.2----
fviz_pca_var(pcaturtles, col.circle = "black") + ggtitle("") +
  xlim(c(-1.2, 1.2)) + ylim(c(-1.2, 1.2))

## ----turtlesinertia, results = "hide"------------------------------------
svd(scaledTurtles)$d/pcaturtles$sdev
sqrt(47)

## ---- xkcd-ev, eval = TRUE, echo = FALSE, fig.show = 'hold', fig.keep = 'high', fig.cap = "Another great xkcd take: this time eigenvectors."----
knitr::include_graphics(c('images/xkcdEigenVectors.png'))

## ---- book-chunk-2, eval = TRUE, echo = FALSE, fig.keep = 'high'---------
knitr::include_graphics('images/book_icon.png', dpi = 400)

## ----corathletes---------------------------------------------------------
cor(athletes) %>% round(1)

## ----screeplota, fig.keep = 'high', fig.cap = "The screeplot is the first thing to consult, it tells us that it is satisfactory to use a two-dimensional plot."----
pca.ath = dudi.pca(athletes, scannf = FALSE)
pca.ath$eig
fviz_eig(pca.ath, geom = "bar", bar_width = 0.3) + ggtitle("")

## ----athletecorr, fig.keep = 'high', fig.cap = "Correlation circle of the original variables.", fig.width = 3, fig.height = 3----
fviz_pca_var(pca.ath, col.circle = "black") + ggtitle("")

## ----atheleteneg---------------------------------------------------------
athletes[, c(1, 5, 6, 10)] = -athletes[, c(1, 5, 6, 10)]
cor(athletes) %>% round(1)
pcan.ath = dudi.pca(athletes, nf = 2, scannf = FALSE)
pcan.ath$eig

## ----athletecorrn, fig.keep = 'high', fig.cap = "Correlation circle after changing the signs of the running variables.",  fig.width = 3, fig.height = 3----
fviz_pca_var(pcan.ath, col.circle="black") + ggtitle("")

## ----athletepc, fig.keep = 'high', fig.cap = "First principal plane showing the projections of the athletes. Do you notice something about the organization of the numbers?",fig.width=3.5,fig.height=3.5----
fviz_pca_ind(pcan.ath) + ggtitle("") + ylim(c(-2.5,5.7))

## ----inputolympic--------------------------------------------------------
data("olympic", package = "ade4")
olympic$score

## ----AthleteScorePCA, fig.keep = 'high', fig.cap = "Scatterplot of the scores given as a supplementary variable and the first principal component. The points are labeled by their order in the data set. We can see a very strong correlation between this supplementary score variable and the first principal coordinate, why is it not a perfectly linear fit?", echo = FALSE, fig.width = 4.5, fig.height = 4.5----
p = ggplot(tibble(pc1 = pcan.ath$li[, 1], score = olympic$score, id = rownames(athletes)),
   aes(x = score, y = pc1, label = id)) + geom_text()
p + stat_smooth(method = "lm", se = FALSE)

## ----screeploteq, fig.keep = 'high', fig.cap = "A screeplot showing \'dangerously\' similar variances. Choosing to cutoff at a hard threshold of 80\\% of the variance would give unstable PC plots. With so such cutoff, the axes corresponding to the 3D subspace of 3 similar eigenvalues are unstable and cannot be individually interpreted.", echo = FALSE, results = "hide", fig.width = 3.5, fig.height = 3.5----
load("../data/screep7.RData")
pcaS7 = dudi.pca(screep7, scannf = FALSE)
fviz_eig(pcaS7,geom="bar",bar_width=0.5) + ggtitle("")
#problem with dudi and prcomp eigenvalues
#prcomp does not scale by default, dudi.pca does
#fviz_eig(pcaS7,geom="bar",width=0.3)
#p7=prcomp(screep7,scale= TRUE)
#p7$sdev^2
#plot(p7)

## ----tcellexpr, fig.keep = 'high', fig.cap = "T-cell expression PCA screeplot.", fig.width = 3.5, fig.height = 3.5----
pcaMsig3 = dudi.pca(Msig3transp, center = TRUE, scale = TRUE,
                    scannf = FALSE, nf = 4)
fviz_screeplot(pcaMsig3) + ggtitle("")

## ----chap8-r-tcelltypes-1, fig.keep = 'high', fig.cap = "PCA of gene expression for a subset of 156 genes involved in specificities of each of the three separate T-cell types: effector, naÃ¯ve and memory. Again, we see that the plot is elongated along the the first axis, as that explains much of the variance. Notice that one of the T-cells seems to be mislabeled.", fig.margin = FALSE, fig.width = 8, fig.height = 2.6----
ids = rownames(Msig3transp)
celltypes = factor(substr(ids, 7, 9))
status = factor(substr(ids, 1, 3))
table(celltypes)
cbind(pcaMsig3$li, tibble(Cluster = celltypes, sample = ids)) %>%
ggplot(aes(x = Axis1, y = Axis2)) +
  geom_point(aes(color = Cluster), size = 5) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_vline(xintercept = 0, linetype = 2) +
  scale_color_discrete(name = "Cluster") + coord_fixed()

## ----xsetinput, eval = FALSE, echo = FALSE-------------------------------
## # For the record:
## library("xcms")
## cdfpath = system.file("cdf", package = "faahKO")
## cdffiles = list.files(cdfpath, recursive = TRUE, full = TRUE)
## xset = xcmsSet(cdffiles)
## xset2 = group(xset)
## xset2 = retcor(xset2)
## xset2 = group(xset2, bw = 10)
## xset3 = fillPeaks(xset2)
## gt = groups(xset3)
## mat1 = groupval(xset3, value = "into")

## ----xset3scree, fig.keep = 'high', fig.cap = "Screeplot showing the eigenvalues for the mice data.", fig.width = 4, fig.height = 4----
load("../data/mat1xcms.RData")
dim(mat1)
pcamat1 = dudi.pca(t(mat1), scannf = FALSE, nf = 3)
fviz_eig(pcamat1, geom = "bar", bar_width = 0.7) + ggtitle("")

## ----Stretchedbiplot, fig.keep = 'high', fig.cap = "The first principal plane for the `mat1` data. It explains (ref:Stretchedbiplot-1)\\% of the variance.", fig.margin = FALSE, fig.width = 9, fig.height = 2.5----
dfmat1 = cbind(pcamat1$li, tibble(
    label = rownames(pcamat1$li),
    number = substr(label, 3, 4),
    type = factor(substr(label, 1, 2))))
pcsplot = ggplot(dfmat1,
  aes(x=Axis1, y=Axis2, label=label, group=number, colour=type)) +
 geom_text(size = 4, vjust = -0.5)+ geom_point(size = 3)+ylim(c(-18,19))
pcsplot + geom_hline(yintercept = 0, linetype = 2) +
  geom_vline(xintercept = 0, linetype = 2)

## ----RedConnects---------------------------------------------------------
pcsplot + geom_line(colour = "red")

## ----WineHeatplot, fig.keep = 'high', fig.cap = "The difference between 1 and the correlation can be used as a distance between variables and is used to make a heatmap of the associations between the variables.",fig.height=4,fig.width=4----
library("pheatmap")
load("../data/wine.RData")
load("../data/wineClass.RData")
wine[1:2, 1:7]
pheatmap(1 - cor(wine), treeheight_row = 0.2)

## ----WineBiplot2, fig.keep = 'high', fig.cap = "PCA biplot including ellipses for the three types of wine: barolo, grignolino and barbera. For each ellipsis, the axis lengths are given by one standard deviation. Small angles between the vectors \x60Phenols\x60, \x60Flav\x60 and \x60Proa\x60 indicate that they are strongly correlated, whereas \x60Hue\x60 and \x60Alcohol\x60 are uncorrelated. ", fig.margin = FALSE, fig.height = 5, fig.width = 6----
winePCAd = dudi.pca(wine, scannf=FALSE)
table(wine.class)
fviz_pca_biplot(winePCAd, geom = "point", habillage = wine.class,
   col.var = "violet", addEllipses = TRUE, ellipse.level = 0.69) +
   ggtitle("") + coord_fixed()

## ----prepareData---------------------------------------------------------
data("x", package = "Hiiragi2013")
xwt = x[, x$genotype == "WT"]
sel = order(rowVars(Biobase::exprs(xwt)), decreasing = TRUE)[1:100]
xwt = xwt[sel, ]
tab = table(xwt$sampleGroup)
tab

## ----resPCADscree, fig.keep = 'high', fig.cap = "Screeplot from the weighted PCA of the Hiiragi data. The drop after the second eigenvalue suggests that a two-dimensional PCA is appropriate.", fig.width = 3.5, fig.height = 3.5----
xwt$weight = 1 / as.numeric(tab[xwt$sampleGroup])
pcaMouse = dudi.pca(as.data.frame(t(Biobase::exprs(xwt))),
  row.w = xwt$weight,
  center = TRUE, scale = TRUE, nf = 2, scannf = FALSE)
fviz_eig(pcaMouse) + ggtitle("")

## ----resPCADplot, fig.keep = 'high', fig.cap = "Output from weighted PCA on the Hiiragi data. The samples are colored according to their groups.", fig.margin = FALSE,fig.width = 7, fig.height = 3.5----
fviz_pca_ind(pcaMouse, geom = "point", col.ind = xwt$sampleGroup) +
  ggtitle("") + coord_fixed()

u = seq(2, 30, by = 2)
v = seq(3, 12, by = 3)
X1 = u %*% t(v)

## ----Materr--------------------------------------------------------------
Materr = matrix(rnorm(60,1),nrow=15,ncol=4)
X = X1+Materr

## ----X1outer, results = "hide"-------------------------------------------
outer(u, v)

## ----ggplotX-------------------------------------------------------------
ggplot(data = data.frame(X), aes(x = X1, y = X2, col = X3, size = X4)) + geom_point()

## ----rank2matrix---------------------------------------------------------
n = 100
p = 4
Y2 = outer(rnorm(n), rnorm(p)) + outer(rnorm(n), rnorm(p))
head(Y2)
ggplot(data=data.frame(Y2), aes(x=X1, y=X2, col=X3, size=X4)) + geom_point()

## ----svdY2---------------------------------------------------------------
svd(Y2)$d # two non-zero eigenvalues
Y = Y2 + matrix(rnorm(n*p, sd=0.01),n,p) # add some noise to Y2
svd(Y)$d # four non-zero eigenvalues (but only 2 big ones)

## ----binormalpc, fig.keep = 'high', fig.show = "hold", fig.cap = "The original data shown in scatterplot (A) and the plot obtained using the principal component rotation (B).", fig.margin = FALSE, out.width = '50%',  fig.width=4.5, fig.height=4.5----
mu1 = 1; mu2 = 2; s1=2.5; s2=0.8; rho=0.9;
sigma = matrix(c(s1^2, s1*s2*rho, s1*s2*rho, s2^2),2)
library("MASS")
sim2d = data.frame(mvrnorm(50, mu = c(mu1,mu2), Sigma = sigma))
svd(scale(sim2d))$d
svd(scale(sim2d))$v[,1]
ggplot(data.frame(sim2d),aes(x=X1,y=X2)) +
    geom_point()
respc=princomp(sim2d)
dfpc = data.frame(pc1=respc$scores[,1],
pc2 = respc$scores[,2])
 ggplot(dfpc,aes(x=pc1,y=pc2)) +
   geom_point() + coord_fixed(2)

## ----constructionMOSAIC,echo=FALSE,eval=FALSE----------------------------
## require(vcd)
## uvec0=c(1,5.2,0.5,3.6)
## n=length(uvec0)-1
## vvec0=c(1,1.5,1.8,2.5,1.4)
## p=length(vvec0)-1
## rankone=function(uvec=uvec0,vvec=vvec0,factr=100){
## Xout=uvec%*%t(vvec)*factr
## n=length(uvec)
## p=length(vvec)
## dimnames(Xout)=list(U=c(" ",paste("u",1:(n-1),sep="")),V=c(" ",paste("v",1:(p-1),sep="")))
## return(Xout)
## }
## 
## Xmat=rankone()
## 
## makelabels=function(Xout=Xmat,step=0){
## tab=as.table(Xout)
## n=nrow(Xout)
## p=ncol(Xout)
##   tab[1,]=rep(NA,p)
## tab[,1]=rep(NA,n)
##   }
##   return(tab)
## }
## 
## tabf0=makelabels(Xmat,step=0)
## tabf1=makelabels(Xmat,step=1)
## Xsub=Xmat[-1,-1]
## dimnames(Xsub)=NULL
## rowns=paste("$x_{",1:n,".}$",sep="")
## colns=paste("$x_{.",1:p,"}$",sep="")
## dimnames(Xsub)=list(rowns,colns)
## require(xtable)
## xtab=xtable(Xsub,floating=FALSE,digits=0)
## xtab

## ----colorspace, echo = FALSE, eval = FALSE------------------------------
## np = prod(dim(Xmat))
## rainbow_colors = colorspace::rainbow_hcl(np, c = 50, l = 70, start = 30, end = 360*(np-1)/np)
## mycols = rainbow_colors[1:np]
## mycols[c(1:(n+1), seq(n+2,(n+1)*(p+1),n+1))] = "white"

## ----mosaicXplot0,echo=FALSE,eval=FALSE----------------------------------
## Xmat0=Xmat
## #dimnames(Xmat0)=NULL
## mosaic(Xmat,pop=FALSE,  gp = gpar(fill=matrix(mycols,ncol=p+1),fontsize=14))
## #tabf0
## #tabf1
## labeling_cells(text = tabf0,clip=FALSE,gp_labels = gpar(fontsize = 14))(tabf0)
## #labeling_border(labels =FALSE)

## ----mosaicXplot1,echo=FALSE,eval=FALSE----------------------------------
## tabf2=tabf1
## tabf2[-1,1]=0.1*tabf1[-1,1]
## tabf2[1,-1]=0.1*tabf1[1,-1]
## mosaic(Xmat,pop=FALSE,  gp = gpar(fill=matrix(mycols,ncol=p+1),fontsize=14))
## labeling_cells(text = tabf2,clip=FALSE,gp_labels = gpar(fontsize = 14))(tabf2)

## ----mosaicXplot2,echo=FALSE,eval=FALSE----------------------------------
## tabf3=tabf1
## tabf3[-1,1]=0.05*tabf1[-1,1]
## tabf3[1,-1]=0.2*tabf1[1,-1]
## mosaic(Xmat,pop=FALSE,  gp = gpar(fill=matrix(mycols,ncol=p+1),fontsize=14))
## labeling_cells(text = tabf3,clip=FALSE,gp_labels = gpar(fontsize = 14))(tabf3)

## ----mosaicXplot3,echo=FALSE,eval=FALSE----------------------------------
## USV=svd(Xsub)
## tabusv=tabf0
## tabusv[1,]=c(round(USV$d[1],1),round(USV$v[,1],1))
## tabusv[-1,1]=round(USV$u[,1],1)
## #dimnames(tabusv)[[1]][1]="s1"
## mosaic(Xmat,pop=FALSE,  gp = gpar(fill=matrix(mycols,ncol=5),fontsize = 14))
## labeling_cells(text = tabusv,clip=FALSE,gp_labels = gpar(fontsize = 14))(tabusv)

## ----mosaicXCplot0,echo=FALSE,eval=FALSE---------------------------------
## u2=c(5,2,3,4,1.5)
## v2=c(2,7,3,4)
## u3=c(0.5,1,2,2,3)
## v3=c(1,0,4,2)
## Xmat2=rankone(c(1,u2),c(1,v2),1)
## Xmat3=rankone(c(1,u3),c(1,v3),5)
## Xmat4=Xmat2+Xmat3
## tab3f0=makelabels(Xmat4,step=0)
## n=5;p=4;
## mycols[c(1:(n+1),seq(n+2,(n+1)*(p+1),n+1))]="white"
## mosaic(Xmat4,pop=FALSE,  gp = gpar(fill=matrix(mycols,ncol=p+1),fontsize=14))
## labeling_cells(text = tab3f0,clip=FALSE,gp_labels = gpar(fontsize = 14))(tab3f0)

## ----mosaicXCplot3,echo=FALSE,eval=FALSE---------------------------------
## tab3f1=makelabels(Xmat3,step=1)
## mosaic(Xmat3,pop=FALSE,  gp = gpar(fill=matrix(mycols,ncol=p+1),fontsize=14))
## labeling_cells(text = tab3f1,clip=FALSE,gp_labels = gpar(fontsize = 14))(tab3f1)

## ----mosaicXCplot2,echo=FALSE,eval=FALSE---------------------------------
## tab2f1=makelabels(Xmat2,step=1)
## mosaic(Xmat2,pop=FALSE,  gp = gpar(fill=matrix(mycols,ncol=p+1),fontsize=14))
## labeling_cells(text = tab2f1,clip=FALSE,gp_labels = gpar(fontsize = 14))(tab2f1)

## ----Xsub234,eval=FALSE,echo=FALSE---------------------------------------
## Xsub4=Xmat4[-1,-1]
## Xsub3=Xmat3[-1,-1]
## Xsub2=Xmat2[-1,-1]
## svd(Xsub3)

